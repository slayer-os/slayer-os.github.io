import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.DPDPlp3K.js";const c=JSON.parse('{"title":"Memory Management in SlayerOS","description":"","frontmatter":{},"headers":[],"relativePath":"guide/architecture/driver.md","filePath":"guide/architecture/driver.md"}'),l={name:"guide/architecture/driver.md"};function t(p,s,r,o,h,d){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="memory-management-in-slayeros" tabindex="-1">Memory Management in SlayerOS <a class="header-anchor" href="#memory-management-in-slayeros" aria-label="Permalink to &quot;Memory Management in SlayerOS&quot;">​</a></h1><p>SlayerOS implements a comprehensive memory management system with four key components: frame allocation, paging, heap management, and memory mapping. This document explains how these components work together to provide efficient memory management.</p><h2 id="memory-layout" tabindex="-1">Memory Layout <a class="header-anchor" href="#memory-layout" aria-label="Permalink to &quot;Memory Layout&quot;">​</a></h2><p>SlayerOS uses a higher-half kernel design where the kernel occupies the upper portion of the virtual address space. This provides:</p><ul><li>Clear separation between user and kernel memory</li><li>Protection against unauthorized access to kernel memory</li><li>Ability to remap user memory independently</li></ul><h2 id="frame-allocator" tabindex="-1">Frame Allocator <a class="header-anchor" href="#frame-allocator" aria-label="Permalink to &quot;Frame Allocator&quot;">​</a></h2><p>The frame allocator manages physical memory at the granularity of 4KB frames.</p><h3 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation" aria-label="Permalink to &quot;Implementation&quot;">​</a></h3><ul><li><strong>Initialization</strong>: <code>Frame::init()</code> parses the Limine-provided memory map to identify usable memory regions</li><li><strong>Tracking</strong>: Uses a bitmap where each bit represents one physical frame (1=used, 0=free)</li><li><strong>API</strong>:<div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Frame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // Allocates a single frame</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Frame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">free</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Releases a previously allocated frame</span></span></code></pre></div></li></ul><p>The allocator carefully avoids regions marked as reserved, bootloader data, or hardware-mapped areas in the memory map.</p><h2 id="paging-system" tabindex="-1">Paging System <a class="header-anchor" href="#paging-system" aria-label="Permalink to &quot;Paging System&quot;">​</a></h2><p>The paging system implements virtual memory using the x86_64 four-level paging structure.</p><h3 id="implementation-1" tabindex="-1">Implementation <a class="header-anchor" href="#implementation-1" aria-label="Permalink to &quot;Implementation&quot;">​</a></h3><ul><li><strong>Page Tables</strong>: Uses PML4, PML3, PML2, and PML1 tables (also known as Page Map Level 4, PDPT, PD, and PT)</li><li><strong>API</strong>:<div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Paging</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                  // Initializes paging</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Paging</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> phys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> virt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint64_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> flags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Maps physical to virtual</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Paging</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> virt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                   // Removes mapping</span></span></code></pre></div></li></ul><h3 id="page-flags" tabindex="-1">Page Flags <a class="header-anchor" href="#page-flags" aria-label="Permalink to &quot;Page Flags&quot;">​</a></h3><ul><li><code>PAGE_PRESENT</code>: Page is in memory</li><li><code>PAGE_WRITABLE</code>: Page can be written to</li><li><code>PAGE_USER</code>: Page is accessible from user mode</li><li><code>PAGE_WRITETHROUGH</code>: Write-through caching</li><li><code>PAGE_NOCACHE</code>: Disable caching</li><li><code>PAGE_NX</code>: No-execute (prevents code execution)</li></ul><h2 id="heap-allocator" tabindex="-1">Heap Allocator <a class="header-anchor" href="#heap-allocator" aria-label="Permalink to &quot;Heap Allocator&quot;">​</a></h2><p>The heap allocator provides dynamic memory allocation (similar to <code>malloc</code>/<code>free</code>).</p><h3 id="implementation-2" tabindex="-1">Implementation <a class="header-anchor" href="#implementation-2" aria-label="Permalink to &quot;Implementation&quot;">​</a></h3><ul><li><strong>Structure</strong>: Divides memory into pages, each containing segments</li><li><strong>Tracking</strong>: Uses linked lists of free and used segments</li><li><strong>API</strong>:<div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmalloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Allocates memory</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kfree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // Frees allocated memory</span></span></code></pre></div></li></ul><p>The allocator implements basic coalescing to prevent fragmentation by merging adjacent free segments.</p><h2 id="memory-mapper" tabindex="-1">Memory Mapper <a class="header-anchor" href="#memory-mapper" aria-label="Permalink to &quot;Memory Mapper&quot;">​</a></h2><p>The memory mapper creates the initial virtual memory layout during kernel initialization.</p><h3 id="implementation-3" tabindex="-1">Implementation <a class="header-anchor" href="#implementation-3" aria-label="Permalink to &quot;Implementation&quot;">​</a></h3><ul><li><strong>Initialization</strong>: <code>Mapper::full_map()</code> sets up all required mappings</li><li><strong>Key Mappings</strong>: <ul><li>Kernel code and data sections</li><li>Higher Half Direct Map (HHDM) for accessing physical memory</li><li>Framebuffer for graphics output</li><li>Bootloader data structures</li></ul></li></ul><h3 id="address-translation" tabindex="-1">Address Translation <a class="header-anchor" href="#address-translation" aria-label="Permalink to &quot;Address Translation&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Convert physical address to virtual</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PHYS2VIRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">addr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ((</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)((</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(addr) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hhdm_offset))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Convert virtual address to physical</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VIRT2PHYS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">addr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ((</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)((</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(addr) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hhdm_offset))</span></span></code></pre></div><h2 id="memory-management-flow" tabindex="-1">Memory Management Flow <a class="header-anchor" href="#memory-management-flow" aria-label="Permalink to &quot;Memory Management Flow&quot;">​</a></h2><ol><li><strong>Boot</strong>: Limine provides memory map and HHDM information</li><li><strong>Initialization</strong>: Frame allocator initializes using memory map</li><li><strong>Paging Setup</strong>: Kernel creates initial page tables</li><li><strong>Mapping</strong>: Memory mapper creates standard mappings</li><li><strong>Heap Setup</strong>: Heap allocator initializes for dynamic allocation</li><li><strong>Runtime</strong>: Kernel uses <code>kmalloc</code>/<code>kfree</code> for memory management</li></ol><h2 id="best-practices" tabindex="-1">Best Practices <a class="header-anchor" href="#best-practices" aria-label="Permalink to &quot;Best Practices&quot;">​</a></h2><ul><li>Always check allocation results for NULL</li><li>Free all allocated memory to prevent leaks</li><li>Use appropriate page flags for security (e.g., NX for data)</li><li>Be aware of alignment requirements for hardware operations</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>\`\`\`markdown:site/docs/guide/architecture/bootloader.md</span></span>
<span class="line"><span># Bootloader Integration in SlayerOS</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SlayerOS uses the Limine bootloader to initialize hardware and load the kernel. This document explains the boot process and how the kernel interacts with Limine.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## Limine Bootloader</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[Limine](https://github.com/limine-bootloader/limine) is a modern bootloader supporting both BIOS and UEFI systems. It provides a clean protocol for retrieving system information and resources.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### Key Features</span></span>
<span class="line"><span></span></span>
<span class="line"><span>- Multiboot2 and Limine protocol support</span></span>
<span class="line"><span>- BIOS and UEFI compatibility</span></span>
<span class="line"><span>- Detailed memory map information</span></span>
<span class="line"><span>- Framebuffer initialization</span></span>
<span class="line"><span>- Module loading capability</span></span>
<span class="line"><span>- SMP initialization</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## Boot Process</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1. Firmware (BIOS/UEFI) loads Limine</span></span>
<span class="line"><span>2. Limine reads its configuration (\`limine.conf\`)</span></span>
<span class="line"><span>3. Limine loads the kernel into memory</span></span>
<span class="line"><span>4. Limine prepares boot information structures</span></span>
<span class="line"><span>5. Control transfers to kernel entry point (\`_start\`)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## Limine Protocol</span></span>
<span class="line"><span></span></span>
<span class="line"><span>The Limine protocol uses a request/response mechanism for communication between the bootloader and kernel.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### Request Structure</span></span>
<span class="line"><span></span></span>
<span class="line"><span>\`\`\`cpp</span></span>
<span class="line"><span>struct limine_request {</span></span>
<span class="line"><span>    uint64_t id[4];         // Unique identifier</span></span>
<span class="line"><span>    uint64_t revision;      // Protocol revision</span></span>
<span class="line"><span>    void *response;         // Filled by bootloader</span></span>
<span class="line"><span>};</span></span></code></pre></div><h3 id="key-requests-used-by-slayeros" tabindex="-1">Key Requests Used by SlayerOS <a class="header-anchor" href="#key-requests-used-by-slayeros" aria-label="Permalink to &quot;Key Requests Used by SlayerOS&quot;">​</a></h3><ul><li><p><strong>Memory Map Request</strong>: <code>limine_memmap_request</code></p><ul><li>Provides information about available memory regions</li><li>Identifies usable, reserved, ACPI, and other memory types</li></ul></li><li><p><strong>Framebuffer Request</strong>: <code>limine_framebuffer_request</code></p><ul><li>Provides initialized graphics framebuffer</li><li>Includes resolution, pixel format, and memory address</li></ul></li><li><p><strong>HHDM Request</strong>: <code>limine_hhdm_request</code></p><ul><li>Provides Higher Half Direct Map offset</li><li>Enables easy physical memory access from kernel space</li></ul></li><li><p><strong>Kernel File Request</strong>: <code>limine_kernel_file_request</code></p><ul><li>Provides information about the kernel ELF file</li><li>Useful for accessing embedded data</li></ul></li></ul><h2 id="boot-context" tabindex="-1">Boot Context <a class="header-anchor" href="#boot-context" aria-label="Permalink to &quot;Boot Context&quot;">​</a></h2><p>SlayerOS stores bootloader information in a central structure:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BootloaderCtx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> limine_memmap_response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">memmap;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> limine_framebuffer_response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fb_info;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> limine_hhdm_response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hhdm;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> limine_kernel_file_response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kernel_file;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BootloaderCtx boot_ctx;</span></span></code></pre></div><p>This structure is populated in <code>bootloader/limine.cxx</code> and accessed throughout the kernel.</p><h2 id="kernel-initialization-sequence" tabindex="-1">Kernel Initialization Sequence <a class="header-anchor" href="#kernel-initialization-sequence" aria-label="Permalink to &quot;Kernel Initialization Sequence&quot;">​</a></h2><ol><li><p><strong>Entry Point</strong>: <code>_start</code> (assembly)</p><ul><li>Sets up stack</li><li>Calls <code>_kernel_start</code></li></ul></li><li><p><strong>Early Initialization</strong>: <code>_kernel_start</code></p><ul><li>Initializes serial port for debugging</li><li>Retrieves bootloader information</li><li>Sets up essential services</li></ul></li><li><p><strong>Memory Setup</strong>:</p><ul><li>Initializes frame allocator using memory map</li><li>Sets up paging system</li><li>Creates memory mappings</li></ul></li><li><p><strong>Driver Initialization</strong>:</p><ul><li>Initializes framebuffer driver</li><li>Sets up other hardware drivers</li></ul></li></ol><h2 id="limine-configuration" tabindex="-1">Limine Configuration <a class="header-anchor" href="#limine-configuration" aria-label="Permalink to &quot;Limine Configuration&quot;">​</a></h2><p>SlayerOS uses a minimal <code>limine.conf</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>TIMEOUT=0</span></span>
<span class="line"><span>SERIAL=yes</span></span>
<span class="line"><span></span></span>
<span class="line"><span>:SlayerOS</span></span>
<span class="line"><span>PROTOCOL=limine</span></span>
<span class="line"><span>KERNEL_PATH=boot/slay.kernel</span></span></code></pre></div><h2 id="building-a-bootable-image" tabindex="-1">Building a Bootable Image <a class="header-anchor" href="#building-a-bootable-image" aria-label="Permalink to &quot;Building a Bootable Image&quot;">​</a></h2><p>The build process:</p><ol><li>Compile kernel into ELF binary</li><li>Create ISO directory structure</li><li>Copy kernel and Limine files</li><li>Generate ISO with xorriso</li><li>Install Limine bootloader to ISO</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Example build command (from Makefile)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">xorriso</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -as</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mkisofs</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> boot/limine/limine-bios-cd.bin</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -no-emul-boot</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -boot-load-size</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -boot-info-table</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    --efi-boot</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> boot/limine/limine-uefi-cd.bin</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -efi-boot-part</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --efi-boot-image</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --protective-msdos-label</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    $(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ISO_DIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-o</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ISO_FILE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="debugging-boot-issues" tabindex="-1">Debugging Boot Issues <a class="header-anchor" href="#debugging-boot-issues" aria-label="Permalink to &quot;Debugging Boot Issues&quot;">​</a></h2><ul><li>Enable serial output with <code>SERIAL=yes</code> in <code>limine.conf</code></li><li>Use QEMU with <code>-serial stdio</code> to view serial output</li><li>Check early initialization code for errors</li><li>Verify memory map is being correctly interpreted</li><li>Ensure kernel entry point is properly aligned</li></ul><h2 id="best-practices-1" tabindex="-1">Best Practices <a class="header-anchor" href="#best-practices-1" aria-label="Permalink to &quot;Best Practices&quot;">​</a></h2><ul><li>Always validate bootloader responses before use</li><li>Don&#39;t rely on bootloader-reclaimable memory after initialization</li><li>Use the provided memory map to avoid overwriting critical regions</li><li>Initialize serial port early for debugging capability</li></ul>`,51)]))}const g=i(l,[["render",t]]);export{c as __pageData,g as default};
