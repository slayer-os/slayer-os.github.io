import{_ as a,c as o,o as t,ag as r}from"./chunks/framework.DPDPlp3K.js";const h=JSON.parse('{"title":"Memory Management","description":"","frontmatter":{},"headers":[],"relativePath":"guide/architecture/memory.md","filePath":"guide/architecture/memory.md"}'),i={name:"guide/architecture/memory.md"};function l(n,e,s,m,c,d){return t(),o("div",null,e[0]||(e[0]=[r('<h1 id="memory-management" tabindex="-1">Memory Management <a class="header-anchor" href="#memory-management" aria-label="Permalink to &quot;Memory Management&quot;">​</a></h1><p>SlayerOS implements a comprehensive memory management system that handles physical and virtual memory allocation, paging, and heap management. This document explains the core components of the memory subsystem.</p><h2 id="memory-layout" tabindex="-1">Memory Layout <a class="header-anchor" href="#memory-layout" aria-label="Permalink to &quot;Memory Layout&quot;">​</a></h2><p>SlayerOS uses a higher-half kernel design, where the kernel is mapped to the higher half of the virtual address space. This separation provides several benefits:</p><ul><li>Clear distinction between user and kernel memory spaces</li><li>Protection against user-mode access to kernel memory</li><li>Ability to remap user memory without affecting kernel memory</li></ul><h2 id="frame-allocator" tabindex="-1">Frame Allocator <a class="header-anchor" href="#frame-allocator" aria-label="Permalink to &quot;Frame Allocator&quot;">​</a></h2><p>The frame allocator manages physical memory at the granularity of frames (typically 4KB blocks).</p><h3 id="key-components" tabindex="-1">Key Components <a class="header-anchor" href="#key-components" aria-label="Permalink to &quot;Key Components&quot;">​</a></h3><ul><li><strong>Initialization</strong>: <code>Frame::init()</code> uses the memory map provided by the Limine bootloader to identify available physical memory.</li><li><strong>Bitmap Tracking</strong>: A bitmap tracks which frames are free and which are allocated.</li><li><strong>Core Functions</strong>: <ul><li><code>Frame::alloc()</code>: Allocates a single free frame</li><li><code>Frame::free(frame)</code>: Returns a previously allocated frame to the free pool</li></ul></li></ul><h3 id="implementation-details" tabindex="-1">Implementation Details <a class="header-anchor" href="#implementation-details" aria-label="Permalink to &quot;Implementation Details&quot;">​</a></h3><p>The frame allocator scans the memory map to find usable memory regions, excluding reserved areas like the kernel itself, bootloader data, and hardware-reserved regions. It then creates a bitmap where each bit represents one physical frame, with 1 indicating &quot;in use&quot; and 0 indicating &quot;free&quot;.</p><h2 id="paging-system" tabindex="-1">Paging System <a class="header-anchor" href="#paging-system" aria-label="Permalink to &quot;Paging System&quot;">​</a></h2><p>The paging system implements virtual memory, allowing the kernel to use more memory than physically available and providing memory protection.</p><h3 id="key-components-1" tabindex="-1">Key Components <a class="header-anchor" href="#key-components-1" aria-label="Permalink to &quot;Key Components&quot;">​</a></h3><ul><li><strong>Page Tables</strong>: SlayerOS uses the x86_64 four-level paging structure (PML4, PML3, PML2, PML1)</li><li><strong>Core Functions</strong>: <ul><li><code>Paging::init()</code>: Initializes the paging system by allocating a PML4 table and setting up initial mappings</li><li><code>Paging::map(phys, virt, flags)</code>: Maps a physical address to a virtual address with specified flags</li><li><code>Paging::unmap(virt)</code>: Removes a virtual memory mapping</li></ul></li></ul><h3 id="page-flags" tabindex="-1">Page Flags <a class="header-anchor" href="#page-flags" aria-label="Permalink to &quot;Page Flags&quot;">​</a></h3><p>The paging system supports various flags for memory mappings:</p><ul><li>Present: Indicates the page is currently in memory</li><li>Writable: Allows write access to the page</li><li>User/Supervisor: Controls whether user-mode code can access the page</li><li>Write-Through: Controls caching behavior</li><li>No-Execute: Prevents code execution from the page</li></ul><h2 id="heap-allocator" tabindex="-1">Heap Allocator <a class="header-anchor" href="#heap-allocator" aria-label="Permalink to &quot;Heap Allocator&quot;">​</a></h2><p>The heap allocator provides dynamic memory allocation within the kernel (similar to <code>malloc</code> in userspace).</p><h3 id="key-components-2" tabindex="-1">Key Components <a class="header-anchor" href="#key-components-2" aria-label="Permalink to &quot;Key Components&quot;">​</a></h3><ul><li><strong>Heap Pages</strong>: The heap is divided into pages, each managed by a <code>heap_page_t</code> structure</li><li><strong>Segments</strong>: Within each page, memory is divided into segments (<code>heap_segment_t</code>)</li><li><strong>Core Functions</strong>: <ul><li><code>kmalloc(size)</code>: Allocates a block of memory of the specified size</li><li><code>kfree(addr)</code>: Frees a previously allocated block of memory</li></ul></li></ul><h3 id="implementation-details-1" tabindex="-1">Implementation Details <a class="header-anchor" href="#implementation-details-1" aria-label="Permalink to &quot;Implementation Details&quot;">​</a></h3><p>The heap allocator uses a linked list of segments to track free and allocated memory blocks. When a memory allocation request is made, it searches for a free segment of sufficient size. If found, it splits the segment if necessary and returns the allocated portion. When memory is freed, adjacent free segments are merged to prevent fragmentation.</p><h2 id="memory-mapper" tabindex="-1">Memory Mapper <a class="header-anchor" href="#memory-mapper" aria-label="Permalink to &quot;Memory Mapper&quot;">​</a></h2><p>The memory mapper is responsible for creating initial memory mappings during kernel initialization.</p><h3 id="key-components-3" tabindex="-1">Key Components <a class="header-anchor" href="#key-components-3" aria-label="Permalink to &quot;Key Components&quot;">​</a></h3><ul><li><strong>Full Mapping</strong>: <code>Mapper::full_map()</code> creates all initial mappings</li><li><strong>Mapping Types</strong>: <ul><li>Kernel text, rodata, and data sections</li><li>Higher Half Direct Map (HHDM) for direct physical memory access</li><li>Framebuffer memory for graphics output</li><li>Bootloader-reclaimable memory</li></ul></li></ul><h3 id="address-translation" tabindex="-1">Address Translation <a class="header-anchor" href="#address-translation" aria-label="Permalink to &quot;Address Translation&quot;">​</a></h3><p>The kernel provides macros for translating between virtual and physical addresses:</p><ul><li><code>PHYS2VIRT(addr)</code>: Converts a physical address to its corresponding virtual address</li><li><code>VIRT2PHYS(addr)</code>: Converts a virtual address to its corresponding physical address</li></ul><h2 id="best-practices" tabindex="-1">Best Practices <a class="header-anchor" href="#best-practices" aria-label="Permalink to &quot;Best Practices&quot;">​</a></h2><p>When working with SlayerOS memory management:</p><ol><li>Always use the appropriate allocation function for your needs</li><li>Free all allocated memory to prevent memory leaks</li><li>Be aware of page boundaries when working with direct memory access</li><li>Use the correct memory flags when mapping memory to ensure proper protection</li></ol>',34)]))}const u=a(i,[["render",l]]);export{h as __pageData,u as default};
