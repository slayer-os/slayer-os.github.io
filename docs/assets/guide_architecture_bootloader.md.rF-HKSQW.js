import{_ as i,c as a,o as t,ag as s}from"./chunks/framework.DPDPlp3K.js";const u=JSON.parse('{"title":"Bootloader","description":"","frontmatter":{},"headers":[],"relativePath":"guide/architecture/bootloader.md","filePath":"guide/architecture/bootloader.md"}'),n={name:"guide/architecture/bootloader.md"};function o(l,e,r,h,p,d){return t(),a("div",null,e[0]||(e[0]=[s(`<h1 id="bootloader" tabindex="-1">Bootloader <a class="header-anchor" href="#bootloader" aria-label="Permalink to &quot;Bootloader&quot;">​</a></h1><p>SlayerOS uses the Limine bootloader to initialize the system and load the kernel. This document explains how the bootloader works and how the kernel interacts with it.</p><h2 id="limine-bootloader" tabindex="-1">Limine Bootloader <a class="header-anchor" href="#limine-bootloader" aria-label="Permalink to &quot;Limine Bootloader&quot;">​</a></h2><p><a href="https://github.com/limine-bootloader/limine" target="_blank" rel="noreferrer">Limine</a> is a modern, feature-rich bootloader that supports both BIOS and UEFI systems. It provides a clean interface for the kernel to retrieve system information and resources.</p><h3 id="key-features" tabindex="-1">Key Features <a class="header-anchor" href="#key-features" aria-label="Permalink to &quot;Key Features&quot;">​</a></h3><ul><li>Multiboot2 and Limine protocol support</li><li>BIOS and UEFI compatibility</li><li>Memory map information</li><li>Framebuffer initialization</li><li>Module loading</li><li>SMP (Symmetric Multiprocessing) initialization</li></ul><h2 id="boot-process" tabindex="-1">Boot Process <a class="header-anchor" href="#boot-process" aria-label="Permalink to &quot;Boot Process&quot;">​</a></h2><ol><li>The system firmware (BIOS or UEFI) loads the Limine bootloader</li><li>Limine parses its configuration file (<code>limine.conf</code>)</li><li>Limine loads the kernel into memory</li><li>Limine prepares the environment (memory map, framebuffer, etc.)</li><li>Limine transfers control to the kernel&#39;s entry point (<code>_start</code>)</li></ol><h2 id="limine-configuration" tabindex="-1">Limine Configuration <a class="header-anchor" href="#limine-configuration" aria-label="Permalink to &quot;Limine Configuration&quot;">​</a></h2><p>The Limine configuration file (<code>misc/boot/limine.conf</code>) specifies various boot parameters:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>TIMEOUT=0</span></span>
<span class="line"><span>SERIAL=yes</span></span>
<span class="line"><span></span></span>
<span class="line"><span>:SlayerOS</span></span>
<span class="line"><span>PROTOCOL=limine</span></span>
<span class="line"><span>KERNEL_PATH=boot/slay.kernel</span></span></code></pre></div><ul><li><code>TIMEOUT=0</code>: Boot immediately without showing a menu</li><li><code>SERIAL=yes</code>: Enable serial output for debugging</li><li><code>:SlayerOS</code>: Start of an entry named &quot;SlayerOS&quot;</li><li><code>PROTOCOL=limine</code>: Use the Limine protocol</li><li><code>KERNEL_PATH=boot/slay.kernel</code>: Path to the kernel binary on the boot medium</li></ul><h2 id="limine-protocol" tabindex="-1">Limine Protocol <a class="header-anchor" href="#limine-protocol" aria-label="Permalink to &quot;Limine Protocol&quot;">​</a></h2><p>The Limine protocol is a communication mechanism between the bootloader and the kernel. The kernel places &quot;requests&quot; in its binary, and the bootloader fills in &quot;responses&quot; before transferring control.</p><h3 id="request-structure" tabindex="-1">Request Structure <a class="header-anchor" href="#request-structure" aria-label="Permalink to &quot;Request Structure&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> limine_request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint64_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint64_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> revision;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">response;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="common-requests" tabindex="-1">Common Requests <a class="header-anchor" href="#common-requests" aria-label="Permalink to &quot;Common Requests&quot;">​</a></h3><p>SlayerOS uses several Limine requests:</p><ul><li><strong>Memory Map Request</strong>: Provides information about available memory regions</li><li><strong>Framebuffer Request</strong>: Provides a framebuffer for graphics output</li><li><strong>HHDM Request</strong>: Provides a Higher Half Direct Map for accessing physical memory</li><li><strong>Kernel File Request</strong>: Provides information about the kernel file</li></ul><h2 id="boot-context" tabindex="-1">Boot Context <a class="header-anchor" href="#boot-context" aria-label="Permalink to &quot;Boot Context&quot;">​</a></h2><p>SlayerOS defines a <code>BootloaderCtx</code> structure to store information provided by the bootloader:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BootloaderCtx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> limine_memmap_response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">memmap;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> limine_framebuffer_response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fb_info;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> limine_hhdm_response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hhdm;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> limine_kernel_file_response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kernel_file;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>This structure is populated in <code>bootloader/limine.cxx</code> and used throughout the kernel.</p><h2 id="kernel-initialization" tabindex="-1">Kernel Initialization <a class="header-anchor" href="#kernel-initialization" aria-label="Permalink to &quot;Kernel Initialization&quot;">​</a></h2><p>After the bootloader transfers control to the kernel, the following steps occur:</p><ol><li>The <code>_start</code> function (assembly) sets up the stack and calls <code>_kernel_start</code></li><li><code>_kernel_start</code> initializes the UART for logging</li><li>The kernel collects bootloader information by accessing the Limine responses</li><li>The kernel initializes the frame allocator using the memory map</li><li>The kernel initializes the paging system</li><li>The kernel initializes the framebuffer for graphics output</li></ol><h2 id="debugging-with-serial-output" tabindex="-1">Debugging with Serial Output <a class="header-anchor" href="#debugging-with-serial-output" aria-label="Permalink to &quot;Debugging with Serial Output&quot;">​</a></h2><p>Limine can redirect kernel output to a serial port for debugging. This is enabled with the <code>SERIAL=yes</code> option in <code>limine.conf</code>. The kernel can then use the serial port for logging and debugging output.</p><h2 id="building-and-running" tabindex="-1">Building and Running <a class="header-anchor" href="#building-and-running" aria-label="Permalink to &quot;Building and Running&quot;">​</a></h2><p>To build an ISO image with Limine and the SlayerOS kernel:</p><ol><li>Compile the kernel</li><li>Create a directory structure for the ISO</li><li>Copy the kernel and Limine files to the appropriate locations</li><li>Use <code>xorriso</code> to create the ISO image</li><li>Install the Limine bootloader to the ISO</li></ol><p>This process is automated in the Makefile with the <code>iso</code> target.</p><h2 id="best-practices" tabindex="-1">Best Practices <a class="header-anchor" href="#best-practices" aria-label="Permalink to &quot;Best Practices&quot;">​</a></h2><p>When working with the bootloader:</p><ol><li>Always check that bootloader responses are valid before using them</li><li>Don&#39;t rely on bootloader-reclaimable memory after initialization</li><li>Use the memory map to avoid overwriting important memory regions</li><li>Initialize essential hardware (like the serial port) early for debugging</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>These documents provide comprehensive information about the memory management system and bootloader in SlayerOS, based on the architecture overview. They explain the key components, their functions, and how they work together to initialize and manage the system.</span></span></code></pre></div>`,36)]))}const m=i(n,[["render",o]]);export{u as __pageData,m as default};
